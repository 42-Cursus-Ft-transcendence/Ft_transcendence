{"version":3,"file":"server.js","mappings":"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","sources":["webpack://fastify-app/webpack/bootstrap","webpack://fastify-app/webpack/runtime/compat get default export","webpack://fastify-app/webpack/runtime/define property getters","webpack://fastify-app/webpack/runtime/hasOwnProperty shorthand","webpack://fastify-app/external node-commonjs \"path\"","webpack://fastify-app/external node-commonjs \"fs\"","webpack://fastify-app/external commonjs \"dotenv\"","webpack://fastify-app/external commonjs \"fastify\"","webpack://fastify-app/external commonjs \"@fastify/websocket\"","webpack://fastify-app/external commonjs \"@fastify/static\"","webpack://fastify-app/external commonjs \"ethers\"","webpack://fastify-app/./src/blockchain.ts","webpack://fastify-app/./src/game.ts","webpack://fastify-app/external commonjs \"@fastify/jwt\"","webpack://fastify-app/external commonjs \"@fastify/cookie\"","webpack://fastify-app/external commonjs \"@fastify/oauth2\"","webpack://fastify-app/external commonjs \"sqlite3\"","webpack://fastify-app/./src/db/db.ts","webpack://fastify-app/external commonjs \"bcrypt\"","webpack://fastify-app/./src/routes/userRoutes.ts","webpack://fastify-app/external node-commonjs \"crypto\"","webpack://fastify-app/./src/server.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"dotenv\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fastify\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@fastify/websocket\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@fastify/static\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ethers\");","// src/back/src/blockchain.ts\nimport path from \"path\";\nimport fs from \"fs\";\nimport dotenv from \"dotenv\";\nimport { ethers } from \"ethers\";\n// 1) Load .env\ndotenv.config({ path: path.resolve(__dirname, \"../.env\") });\n// 2) RPC & provider\nconst RPC_URL = process.env.AVALANCHE_RPC;\nif (!RPC_URL)\n    throw new Error(\"Missing AVALANCHE_RPC in .env\");\nconst provider = new ethers.JsonRpcProvider(RPC_URL);\n// 3) Wallet signer\nconst PK = process.env.PRIVATE_KEY;\nif (!PK)\n    throw new Error(\"Missing PRIVATE_KEY in .env\");\nconst wallet = new ethers.Wallet(PK, provider);\n// 4) Load ABI\nconst artifact = JSON.parse(fs.readFileSync(path.resolve(__dirname, \"../../../contracts/out/ScoreBoard.sol/ScoreBoard.json\"), \"utf8\"));\nconst abi = artifact.abi;\n// 5) Instantiate contract\nconst SCOREBOARD_ADDRESS = process.env.SCOREBOARD_ADDRESS;\nif (!SCOREBOARD_ADDRESS)\n    throw new Error(\"Missing SCOREBOARD_ADDRESS in .env\");\nexport const scoreboard = new ethers.Contract(SCOREBOARD_ADDRESS, abi, wallet);\n// 6) Internal pending‐nonce tracker\nlet _nextNonce = null;\nasync function getNextNonce() {\n    if (_nextNonce === null) {\n        // fetch including pending txs\n        _nextNonce = await provider.getTransactionCount(wallet.address, \"pending\");\n    }\n    const curr = _nextNonce;\n    _nextNonce++;\n    return curr;\n}\n// 7) submit a score, handing out unique nonces\nexport async function postScore(gameId, player, score) {\n    if (!ethers.isAddress(player)) {\n        throw new Error(\"Invalid player address\");\n    }\n    if (!Number.isInteger(score) || score < 0) {\n        throw new Error(\"Score must be a non-negative integer\");\n    }\n    const key = ethers.id(gameId); // keccak256 of UTF-8 bytes\n    const nonce = await getNextNonce(); // unique, incremental\n    const tx = await scoreboard.submitScore(key, player, score, { nonce });\n    await tx.wait();\n    return tx.hash;\n}\n// 8) fetch stored scores\nexport async function fetchScores(gameId) {\n    const key = ethers.id(gameId);\n    const raw = await scoreboard.getScores(key);\n    return raw.map((r) => ({\n        player: r.player,\n        score: Number(r.score),\n    }));\n}\n","// src/back/src/game.ts\n/** Linear interpolation between a and b:\n *  t=0 → returns a\n *  t=1 → returns b\n *  values in between smoothly interpolate.\n */\nfunction lerp(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Super-smooth AI for Pong: always glides toward the predicted ball intersection, even when waiting.\n * Difficulty controls accuracy and approach speed.\n */\nexport function startAI(game, difficulty) {\n    // Tune these:\n    const MIN_SPEED = 0.7; // slowest pixels per frame\n    const MAX_SPEED = 4; // fastest pixels per frame\n    const MAX_NOISE = 48; // most error at low difficulty\n    const MIN_NOISE = 0; // no error at high difficulty\n    // Compute params\n    const paddleSpeed = lerp(MIN_SPEED, MAX_SPEED, difficulty);\n    const noise = lerp(MAX_NOISE, MIN_NOISE, difficulty);\n    // Store last observation time and the target position decided from that observation\n    let lastObservation = Date.now();\n    let targetY = game.height / 2;\n    // Store a snapshot of the game state\n    let snapshot = {\n        ball: { ...game.ball },\n        paddleX: game.p2.x,\n        height: game.height\n    };\n    return setInterval(() => {\n        const now = Date.now();\n        // Only observe the game state once per second\n        if (now - lastObservation >= 1000) {\n            lastObservation = now;\n            // Take a snapshot of the current game state\n            snapshot = {\n                ball: { ...game.ball },\n                paddleX: game.p2.x,\n                height: game.height\n            };\n            // Predict where the ball will intersect paddle x using the snapshot\n            const { x: bx0, y: by0, dx, dy } = snapshot.ball;\n            if (dx > 0) {\n                // Simulate ball movement to paddle X\n                let bx = bx0, by = by0, vx = dx, vy = dy;\n                while (bx < snapshot.paddleX) {\n                    bx += vx;\n                    by += vy;\n                    if (by < 0 || by > snapshot.height) {\n                        vy = -vy;\n                        by = Math.max(0, Math.min(snapshot.height, by));\n                    }\n                }\n                targetY = by + (Math.random() * 2 - 1) * noise;\n            }\n            else {\n                // Ball moving away, return to center\n                targetY = snapshot.height / 2;\n            }\n        }\n        // Every frame, move toward the target position\n        // This happens at 60fps regardless of observation frequency\n        const paddleCenter = game.p2.y + Game.PADDLE_HEIGHT / 2;\n        const delta = targetY - paddleCenter;\n        // Determine which direction to move based on target position\n        if (Math.abs(delta) < paddleSpeed) {\n            // Close enough, stop moving\n            game.applyInput('p2', 'stop');\n        }\n        else if (delta > 0) {\n            // Target is below paddle, move down\n            game.applyInput('p2', 'down');\n        }\n        else {\n            // Target is above paddle, move up\n            game.applyInput('p2', 'up');\n        }\n    }, 1000 / 60); // Run at 60 FPS for smooth movement\n}\nclass Game {\n    constructor() {\n        this.height = Game.HEIGHT;\n        this.mode = 'player';\n        this.p1 = { x: 0, y: (Game.HEIGHT - Game.PADDLE_HEIGHT) / 2 };\n        this.p2 = { x: Game.WIDTH - 10, y: (Game.HEIGHT - Game.PADDLE_HEIGHT) / 2 };\n        this.ball = {\n            x: Game.WIDTH / 2,\n            y: Game.HEIGHT / 2,\n            dx: 2,\n            dy: 1\n        };\n        this.score = [0, 0];\n        this.inputs = {\n            p1: 'stop',\n            p2: 'stop'\n        };\n    }\n    /** Apply a direction input ('up', 'down', 'stop') for the given player */\n    applyInput(player, dir) {\n        this.inputs[player] = dir;\n    }\n    /** Advance the game state by one tick */\n    update() {\n        // Move paddles\n        if (this.inputs.p1 === 'up')\n            this.p1.y -= Game.PADDLE_SPEED;\n        if (this.inputs.p1 === 'down')\n            this.p1.y += Game.PADDLE_SPEED;\n        if (this.inputs.p2 === 'up')\n            this.p2.y -= Game.PADDLE_SPEED;\n        if (this.inputs.p2 === 'down')\n            this.p2.y += Game.PADDLE_SPEED;\n        // Clamp paddle positions\n        this.p1.y = Math.max(0, Math.min(Game.HEIGHT - Game.PADDLE_HEIGHT, this.p1.y));\n        this.p2.y = Math.max(0, Math.min(Game.HEIGHT - Game.PADDLE_HEIGHT, this.p2.y));\n        // Move ball\n        this.ball.x += this.ball.dx;\n        this.ball.y += this.ball.dy;\n        // Bounce off top/bottom\n        if (this.ball.y < 0 || this.ball.y > Game.HEIGHT) {\n            this.ball.dy *= -1;\n        }\n        // Paddle collisions\n        const med1 = this.p1.y + Game.PADDLE_HEIGHT / 2;\n        if (this.ball.x < this.p1.x + 10 &&\n            this.ball.y > this.p1.y &&\n            this.ball.y < this.p1.y + Game.PADDLE_HEIGHT &&\n            this.ball.dx < 0) {\n            this.ball.dx = -this.ball.dx + Game.BALL_ACCEL;\n            this.ball.dy = (this.ball.y - med1) / 10;\n        }\n        const med2 = this.p2.y + Game.PADDLE_HEIGHT / 2;\n        if (this.ball.x > this.p2.x - 10 &&\n            this.ball.y > this.p2.y &&\n            this.ball.y < this.p2.y + Game.PADDLE_HEIGHT &&\n            this.ball.dx > 0) {\n            this.ball.dx = -this.ball.dx - Game.BALL_ACCEL;\n            this.ball.dy = (this.ball.y - med2) / 10;\n        }\n        // Score & reset\n        if (this.ball.x < 0) {\n            this.score[1]++;\n            this.resetBall();\n        }\n        if (this.ball.x > Game.WIDTH) {\n            this.score[0]++;\n            this.resetBall();\n        }\n    }\n    /** Reset the ball to the center with a randomized vertical direction */\n    resetBall() {\n        this.ball.x = Game.WIDTH / 2;\n        this.ball.y = Game.HEIGHT / 2;\n        this.ball.dx = this.ball.dx > 0 ? -2 : 2;\n        this.ball.dy = Math.random() > 0.5 ? 1 : -1;\n    }\n    /** Retrieve the current game state for sending to clients */\n    getState() {\n        return {\n            type: 'state',\n            p1: { ...this.p1 },\n            p2: { ...this.p2 },\n            ball: { x: this.ball.x, y: this.ball.y },\n            score: [...this.score]\n        };\n    }\n}\nGame.WIDTH = 600;\nGame.HEIGHT = 400;\nGame.PADDLE_SPEED = 4;\nGame.PADDLE_HEIGHT = 80;\nGame.BALL_ACCEL = 0.5;\nexport default Game;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@fastify/jwt\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@fastify/cookie\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@fastify/oauth2\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"sqlite3\");","import path from 'path';\nimport fs from 'fs';\nimport sqlite3 from 'sqlite3';\nconst dbPath = path.resolve(__dirname, process.env.DB_PATH || '../../data/db.sqlite');\nfs.mkdirSync(path.dirname(dbPath), { recursive: true });\nexport const db = new sqlite3.Database(dbPath, err => {\n    if (err)\n        console.error(err);\n    else\n        console.log('✅ SQLite ready');\n});\ndb.serialize(() => {\n    db.run(`PRAGMA foreign_keys = ON;`);\n    db.run(`\r\n    CREATE TABLE IF NOT EXISTS User (\r\n      idUser            INTEGER PRIMARY KEY,\r\n      userName          TEXT UNIQUE,\r\n      email             TEXT,\r\n      password          TEXT,\r\n      address           TEXT,\r\n      privkey           TEXT,\r\n      registrationDate  TEXT,\r\n      connectionStatus  INTEGER\r\n    );\r\n  `);\n    db.run(`\r\n    CREATE TABLE IF NOT EXISTS Match(\r\n      idMatch           INTEGER PRIMARY KEY,\r\n      matchDate         TEXT,\r\n      player1Score      INTEGER,\r\n      player2Score      INTEGER,\r\n      winnerId          INTEGER,\r\n      FOREIGN KEY(winnerId) REFERENCES User(idUSer)\r\n    );\r\n  `);\n    db.run(`\r\n    CREATE TABLE IF NOT EXISTS User_Match (\r\n      userId            INTEGER ,\r\n      matchDate         TEXT,\r\n      matchId           INTEGER,\r\n      PRIMARY KEY (userId, matchId),\r\n      FOREIGN KEY(userId) REFERENCES User(idUSer),\r\n      FOREIGN KEY(matchId) REFERENCES Match(idMatch)\r\n    );\r\n  `);\n    db.run(`INSERT OR IGNORE INTO User(userName, email, password, registrationDate, address, privkey, connectionStatus)\r\n                VALUES ('Jarvis', 'antarctica', 0, 'forever', 0, 0, 0)`);\n});\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bcrypt\");","import { db } from \"../db/db\";\nimport bcrypt from \"bcrypt\";\nimport { Wallet } from \"ethers\";\nfunction runAsync(sql, values) {\n    return new Promise((resolve, reject) => {\n        db.run(sql, values, function (error) {\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(this.lastID);\n            }\n        });\n    });\n}\nexport function getAsync(sql, params) {\n    return new Promise((resolve, rejects) => {\n        db.get(sql, params, (err, row) => {\n            if (err)\n                rejects(err);\n            else\n                resolve(row ?? null);\n        });\n    });\n}\nexport default async function userRoutes(app) {\n    console.log(\"🛠️  userRoutes mounted\");\n    app.post(\"/signup\", async (request, reply) => {\n        console.log(\">> Reçu POST /user\");\n        // Récupère et valide le body\n        const { userName, email, password } = request.body;\n        if (!userName || !email || !password)\n            return reply\n                .status(400)\n                .send({ error: \"userName, email and password required\" });\n        try {\n            const hashPass = await bcrypt.hash(password, 10);\n            const now = new Date().toString();\n            const userWallet = Wallet.createRandom();\n            const address = userWallet.address;\n            const privKey = userWallet.privateKey;\n            const idUser = await runAsync(`INSERT INTO User(userName, email, password, registrationDate, address, privkey, connectionStatus)\r\n                VALUES (?, ?, ?, ?, ?, ?, 0)`, [userName, email, hashPass, now, address, privKey]);\n            return reply.status(201).send({ idUser });\n        }\n        catch (err) {\n            if (err.code === \"SQLITE_CONSTRAINT\") {\n                return reply.status(409).send({ error: \"Username already taken\" });\n            }\n            return reply.status(500).send({ error: \"Internal server error\" });\n        }\n    });\n    app.post(\"/login\", async (request, reply) => {\n        console.log(\">> Recu POST /login\");\n        const { userName, password } = request.body;\n        if (!userName || !password)\n            return reply\n                .status(400)\n                .send({ error: \"userName and password required\" });\n        try {\n            const user = await getAsync(`SELECT idUser, email, password, connectionStatus FROM User WHERE userName = ?`, [userName]);\n            if (!user)\n                return reply\n                    .status(401)\n                    .send({ error: \"Invalid username or password\" });\n            const match = await bcrypt.compare(password, user.password);\n            if (!match)\n                return reply\n                    .status(401)\n                    .send({ error: \"Invalid username or password\" });\n            await runAsync(`UPDATE User SET connectionStatus = 1 WHERE idUser = ?`, [\n                user.idUser,\n            ]);\n            const token = app.jwt.sign({ sub: user.idUser, userName }, { expiresIn: \"2h\" });\n            return reply\n                .setCookie(\"token\", token, {\n                // signed: true,\n                httpOnly: true,\n                path: \"/\",\n                sameSite: \"strict\",\n                // secure:   true\n            })\n                .status(200)\n                .send({\n                userName,\n                email: user.email,\n                idUser: user.idUser,\n            });\n        }\n        catch (err) {\n            return reply.status(500).send({ error: \"Internal server error\" });\n        }\n    });\n    app.post(\"/me\", { preHandler: [app.authenticate] }, async (request, reply) => {\n        const idUser = request.user.sub;\n        const userName = request.user.userName;\n        try {\n            const res = await getAsync(`SELECT email FROM User WHERE idUser = ?`, [idUser]);\n            if (!res)\n                return reply.status(401).send({ error: \"User not found\" });\n            reply.status(200).send({\n                idUser,\n                userName,\n                email: res.email,\n            });\n        }\n        catch (err) {\n            return reply.status(500).send({ error: \"Internal server error\" });\n        }\n    });\n    app.post(\"/logout\", { preHandler: [app.authenticate] }, async (request, reply) => {\n        // Récupère directement l’ID depuis le payload du JWT\n        const idUser = request.user.sub;\n        try {\n            await runAsync(`UPDATE User SET connectionStatus = 0 WHERE idUser = ?`, [idUser]);\n            return reply\n                .setCookie(\"token\", \"\", {\n                httpOnly: true,\n                path: \"/\",\n                maxAge: 0,\n                sameSite: \"strict\",\n                // secure:   true\n            })\n                .status(200)\n                .send({ ok: true });\n        }\n        catch (err) {\n            return reply\n                .setCookie(\"token\", \"\", {\n                httpOnly: true,\n                path: \"/\",\n                maxAge: 0,\n                sameSite: \"strict\",\n                // secure:   true\n            })\n                .status(200)\n                .send({ ok: true });\n        }\n    });\n    app.get(\"/login/google\", (request, reply) => {\n        // 플러그인 이름(name)으로 generateAuthorizationUri()가 생깁니다.\n        const { uri } = app.googleOAuth2.generateAuthorizationUri(request);\n        // 브라우저를 구글 로그인 화면으로 리다이렉트\n        reply.redirect(uri);\n    });\n    app.get(\"/auth/google\", async (request, reply) => {\n        try {\n            // Authorization Code Flow를 통해 액세스 토큰 획득\n            const tokenResult = await app.googleOAuth2.getAccessTokenFromAuthorizationCodeFlow(request);\n            const accessToken = tokenResult.token.access_token;\n            if (!accessToken) {\n                throw new Error(\"No access token received\");\n            }\n            // Node 18 이상에서는 내장 fetch 사용 (별도의 라이브러리 설치 불필요)\n            const response = await fetch(`https://www.googleapis.com/oauth2/v3/userinfo?access_token=${accessToken}`);\n            const userInfo = await response.json();\n            // 여기서 데이터베이스에 해당 사용자가 없다면 회원가입을 진행할 수 있으며,\n            // 이미 등록된 사용자라면 JWT를 발급합니다.\n            const salt = await bcrypt.genSalt(10);\n            const { sub, email, name } = userInfo;\n            const [hashedSub, hashedEmail] = await Promise.all([\n                bcrypt.hash(sub, salt),\n                bcrypt.hash(email, salt),\n            ]);\n            const jwtToken = app.jwt.sign({\n                sub: hashedSub,\n                email: hashedEmail,\n                name,\n            });\n            // const existingUser = await User.findOne({\n            //   where: { sub: hashedSub },\n            // });\n            // if (!existingUser) {\n            //   await User.create({\n            //     sub: hashedSub,\n            //     email: hashedEmail,\n            //     username: name,\n            //   });\n            // }\n            return reply.send({ token: jwtToken, userInfo: userInfo });\n        }\n        catch (err) {\n            app.log.error(\"Google OAuth error: \" + err.message);\n            reply\n                .code(500)\n                .send({ error: \"Google OAuth error\", details: err.message });\n        }\n    });\n}\nexport async function createGame(idp1, idp2, p1score, p2score) {\n    // 1) On génère la date au format ISO (meilleur pour SQLite)\n    const date = new Date().toISOString();\n    // 2) On détermine le gagnant\n    const winner = p1score > p2score ? idp1 : idp2;\n    // 3) On crée la partie et on récupère son ID\n    const gameId = await runAsync(`INSERT INTO Match(matchDate, player1Score, player2Score, winnerId)\r\n     VALUES (?, ?, ?, ?)`, [date, p1score, p2score, winner]);\n    // 4) On lie chaque joueur à cette partie\n    //    ⚠️ Si tu veux stocker la date dans User_Match, tu peux,\n    //    mais ce champ est redondant (tu l’as déjà dans Match.matchDate).\n    await runAsync(`INSERT INTO User_Match(userId, matchDate, matchId)\r\n     VALUES (?, ?, ?)`, [idp1, date, gameId]);\n    await runAsync(`INSERT INTO User_Match(userId, matchDate, matchId)\r\n     VALUES (?, ?, ?)`, [idp2, date, gameId]);\n    return gameId;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"crypto\");","import path from \"path\";\nimport fs from \"fs\";\nimport dotenv from \"dotenv\";\n// 1) Load .env before anything else reads process.env\ndotenv.config({ path: path.resolve(__dirname, \"../.env\") });\nimport Fastify from \"fastify\";\nimport fastifyWebsocket from \"@fastify/websocket\";\nimport fastifyStatic from \"@fastify/static\";\nimport { ethers } from \"ethers\";\nimport { postScore, fetchScores } from \"./blockchain\";\nimport Game, { startAI } from \"./game\";\nimport fastifyJwt from \"@fastify/jwt\";\nimport fastifyCookie from \"@fastify/cookie\";\nimport fastifyOauth2 from \"@fastify/oauth2\";\nimport userRoutes from \"./routes/userRoutes\"; // ← import par défaut\nimport \"./db/db\"; // ← initialise la BD et les tables\nimport { getAsync } from \"./routes/userRoutes\";\nimport crypto from \"crypto\";\n// ─────────────────────────────────────────────────────────────────────────────\n// Determine frontend directory\n// ─────────────────────────────────────────────────────────────────────────────\nconst prodDir = path.resolve(__dirname, \"../public\");\nconst devDir = path.resolve(__dirname, \"../../../src/front/public\");\nlet publicDir;\nif (fs.existsSync(prodDir)) {\n    publicDir = prodDir;\n}\nelse if (fs.existsSync(devDir)) {\n    publicDir = devDir;\n}\nelse {\n    console.error(\"❌ Frontend directory not found\");\n    process.exit(1);\n}\nconsole.log(\"⛳️ Serving static from:\", publicDir);\nconst waiting = [];\nconst sessions = new Map();\nconst socketToSession = new Map();\n// ─────────────────────────────────────────────────────────────────────────────\n// Create Fastify + register WebSocket plugin\n// ─────────────────────────────────────────────────────────────────────────────\nconst app = Fastify();\nconsole.log(\"Fastify instance created\");\n// cookie\napp.register(fastifyCookie, {\n    secret: process.env.COOKIE_SECRET || \"une_autre_chaine_complexe\", // signe/encrypte les cookies\n    parseOptions: {},\n});\n// JWT\napp.register(fastifyJwt, {\n    secret: process.env.JWT_SECRET || \"une_chaine_tres_complexe\",\n    cookie: {\n        cookieName: \"token\", // le nom exact de ton cookie\n        signed: false, // true si tu utilises la signature de fastify-cookie\n    },\n    sign: {\n        expiresIn: \"2h\",\n    },\n});\n// OAuth2\napp.register(fastifyOauth2, {\n    name: \"googleOAuth2\",\n    scope: [\"profile\", \"email\"],\n    credentials: {\n        client: {\n            id: process.env.GOOGLE_CLIENT_ID,\n            secret: process.env.GOOGLE_CLIENT_SECRET,\n        },\n        auth: fastifyOauth2.GOOGLE_CONFIGURATION,\n    },\n    startRedirectPath: \"/login/google\", // 인증 시작 URL\n    callbackUri: process.env.GOOGLE_CALLBACK_URL, // 인증 후 callback URL\n    callbackUriParams: {\n        // callbackUri에 추가할 custom query 파라미터\n        access_type: \"offline\", // refresh token도 받기 위해 'offline' 모드를 요청\n    },\n    pkce: \"S256\",\n});\napp.decorate(\"authenticate\", async function (request, reply) {\n    console.log(\"Cookies reçus:\", request.cookies);\n    console.log(\"Authorization header:\", request.headers.authorization);\n    try {\n        await request.jwtVerify();\n    }\n    catch (err) {\n        reply.send(err);\n    }\n});\n// bd routes\napp.register(userRoutes);\n// Register WebSocket plugin without any options\napp.register(fastifyWebsocket);\nconsole.log(\"WebSocket plugin registered\");\n// ─────────────────────────────────────────────────────────────────────────────\n// WebSocket endpoint: /ws\n// ─────────────────────────────────────────────────────────────────────────────\n// ─────────────────────────────────────────────────────────────────────────────\n// WebSocket endpoint: /ws (with online matchmaking + bot + local play)\n// ─────────────────────────────────────────────────────────────────────────────\napp.register(async (fastify) => {\n    fastify.get(\"/ws\", {\n        websocket: true,\n        preHandler: [fastify.authenticate],\n    }, (socket, request) => {\n        // const { socket } = connection;\n        const payload = request.user;\n        console.log(`✅ WS client connected: user #${payload.userName}`);\n        let localGame = new Game();\n        let localLoop;\n        let localAI;\n        socket.on(\"message\", async (raw) => {\n            let msg;\n            try {\n                msg = JSON.parse(raw.toString());\n                console.log(msg);\n            }\n            catch {\n                return socket.send(JSON.stringify({ type: \"error\", message: \"Invalid JSON\" }));\n            }\n            switch (msg.type) {\n                // 1) START: decide online vs bot vs local\n                case \"start\":\n                    if (msg.vs === \"online\") {\n                        if (waiting.length > 0) {\n                            const opponent = waiting.shift();\n                            const p1 = opponent.payload;\n                            const p2 = payload;\n                            const gameId = crypto.randomUUID();\n                            const sessionGame = new Game();\n                            sessionGame.mode = \"online\";\n                            const loopTimer = setInterval(() => {\n                                sessionGame.update();\n                                const state = JSON.stringify(sessionGame.getState());\n                                opponent.socket.send(state);\n                                socket.send(state);\n                            }, 1000 / 60);\n                            const session = {\n                                id: gameId,\n                                game: sessionGame,\n                                sockets: { p1: opponent.socket, p2: socket },\n                                players: { p1, p2 },\n                                loopTimer,\n                            };\n                            sessions.set(gameId, session);\n                            socketToSession.set(opponent.socket, session);\n                            socketToSession.set(socket, session);\n                            opponent.socket.send(JSON.stringify({ type: \"matchFound\", gameId, youAre: \"p1\" }));\n                            socket.send(JSON.stringify({ type: \"matchFound\", gameId, youAre: \"p2\" }));\n                        }\n                        else {\n                            waiting.push({ socket, payload });\n                            socket.send(JSON.stringify({ type: \"waiting\" }));\n                        }\n                        return;\n                    }\n                    // BOT or LOCAL PLAYER\n                    localGame = new Game();\n                    localLoop = setInterval(() => {\n                        localGame.update();\n                        socket.send(JSON.stringify(localGame.getState()));\n                    }, 1000 / 60);\n                    if (msg.vs === \"bot\") {\n                        localGame.mode = \"bot\";\n                        const diff = parseFloat(msg.difficulty) || 0;\n                        localAI = startAI(localGame, 1);\n                    }\n                    return;\n                // 2) INPUT: route to the correct game instance\n                case \"input\": {\n                    const sess = socketToSession.get(socket);\n                    if (sess) {\n                        const who = socket === sess.sockets.p1 ? \"p1\" : \"p2\";\n                        sess.game.applyInput(who, msg.dir);\n                        return;\n                    }\n                    const ply = msg.player === \"p2\" ? \"p2\" : \"p1\";\n                    if (ply === \"p2\" && localGame.mode !== \"player\")\n                        return;\n                    localGame.applyInput(ply, msg.dir);\n                    return;\n                }\n                // 3) STOP: tear down the correct session and save scores\n                case \"stop\": {\n                    const sess = socketToSession.get(socket);\n                    if (sess) {\n                        clearInterval(sess.loopTimer);\n                        sess.sockets.p1.send(JSON.stringify({\n                            type: \"STOP\",\n                            score1: sess.game.score[0],\n                            score2: sess.game.score[1],\n                        }));\n                        sess.sockets.p2.send(JSON.stringify({ type: \"STOP\" }));\n                        sessions.delete(sess.id);\n                        socketToSession.delete(sess.sockets.p1);\n                        socketToSession.delete(sess.sockets.p2);\n                        const row1 = await getAsync(`SELECT address FROM User WHERE idUser = ?`, [sess.players.p1.sub]);\n                        const row2 = await getAsync(`SELECT address FROM User WHERE idUser = ?`, [sess.players.p2.sub]);\n                        if (!row1 || !row2) {\n                            console.error(\"Missing on-chain address for one of the players\");\n                        }\n                        else {\n                            // 3) Post both scores on-chain\n                            console.log(\"blockchain posting\");\n                            try {\n                                const tx1 = await postScore(sess.id, row1.address, sess.game.score[0]);\n                                const tx2 = await postScore(sess.id, row2.address, sess.game.score[1]);\n                                console.log(\"Scores posted:\", tx1, tx2);\n                            }\n                            catch (err) {\n                                console.error(\"postScore failed:\", err);\n                            }\n                        }\n                        const result = JSON.stringify({\n                            type: \"matchOver\",\n                            gameId: sess.id,\n                            score: sess.game.score,\n                        });\n                        // sess.sockets.p1.send(result);\n                        // sess.sockets.p2.send(result);\n                        return;\n                    }\n                    console.log(\"Game over, saving local scores\");\n                    if (localLoop) {\n                        clearInterval(localLoop);\n                        localLoop = undefined;\n                    }\n                    if (localAI) {\n                        clearInterval(localAI);\n                        localAI = undefined;\n                    }\n                    // TODO: post localGame.score on–chain here…\n                    return;\n                }\n                case \"stoplobby\":\n                    {\n                        // Rebuild the array without the one you want to drop\n                        let item = waiting.findIndex((w) => w.socket === socket);\n                        if (item >= 0)\n                            waiting.splice(item, 1);\n                    }\n                    return;\n                default:\n                    return socket.send(JSON.stringify({ type: \"error\", message: \"Unknown message type\" }));\n            }\n        });\n        socket.on(\"close\", () => {\n            const idx = waiting.findIndex((w) => w.socket === socket);\n            if (idx >= 0)\n                waiting.splice(idx, 1);\n            const sess = socketToSession.get(socket);\n            if (sess) {\n                clearInterval(sess.loopTimer);\n                sessions.delete(sess.id);\n                socketToSession.delete(sess.sockets.p1);\n                socketToSession.delete(sess.sockets.p2);\n            }\n            if (localLoop)\n                clearInterval(localLoop);\n            if (localAI)\n                clearInterval(localAI);\n            console.log(\"⚠️ WS client disconnected\");\n        });\n    });\n});\n// ─────────────────────────────────────────────────────────────────────────────\n// HTTP API: on-chain scores\n// ─────────────────────────────────────────────────────────────────────────────\napp.post(\"/api/scores\", async (req, reply) => {\n    try {\n        const { gameId, player, score } = req.body;\n        if (!gameId || !ethers.isAddress(player) || typeof score !== \"number\") {\n            return reply.status(400).send({ error: \"Invalid payload\" });\n        }\n        const txHash = await postScore(gameId, player, score);\n        reply.send({ txHash });\n    }\n    catch (err) {\n        console.error(\"POST /api/scores error:\", err);\n        const message = err instanceof Error ? err.message : \"Internal error\";\n        reply.status(500).send({ error: message });\n    }\n});\napp.get(\"/api/scores/:gameId\", async (req, reply) => {\n    try {\n        const gameId = req.params.gameId;\n        console.log(gameId);\n        const scores = await fetchScores(gameId);\n        reply.send(scores);\n    }\n    catch (err) {\n        console.error(\"GET /api/scores error:\", err);\n        const message = err instanceof Error ? err.message : \"Internal error\";\n        reply.status(500).send({ error: message });\n    }\n});\n// ─────────────────────────────────────────────────────────────────────────────\n// Serve static frontend & SPA fallback (excluding /ws & /api)\n// ─────────────────────────────────────────────────────────────────────────────\napp.register(fastifyStatic, {\n    root: publicDir,\n    prefix: \"/\",\n    index: [\"index.html\"],\n    wildcard: false,\n});\napp.get(\"/favicon.ico\", (_req, reply) => {\n    const ico = path.join(publicDir, \"favicon.ico\");\n    if (fs.existsSync(ico)) {\n        reply.header(\"Content-Type\", \"image/x-icon\").send(fs.readFileSync(ico));\n    }\n    else {\n        reply.code(204).send();\n    }\n});\napp.setNotFoundHandler((req, reply) => {\n    const url = req.raw.url || \"\";\n    // let /ws handshake and /api pass through\n    if (url.startsWith(\"/ws\") || url.startsWith(\"/api\")) {\n        return reply.callNotFound();\n    }\n    reply.sendFile(\"index.html\");\n});\n// ─────────────────────────────────────────────────────────────────────────────\n// SQLite for local logging (optional)\n// ─────────────────────────────────────────────────────────────────────────────\n// ─────────────────────────────────────────────────────────────────────────────\n// Start server\n// ─────────────────────────────────────────────────────────────────────────────\nconst PORT = Number(process.env.PORT) || 3000;\napp\n    .listen({ port: PORT, host: \"0.0.0.0\" })\n    .then(() => console.log(`🚀 Server running on http://0.0.0.0:${PORT}`))\n    .catch((err) => {\n    console.error(err);\n    process.exit(1);\n});\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","require","path","__dirname","RPC_URL","process","env","AVALANCHE_RPC","Error","provider","ethers","JsonRpcProvider","PK","PRIVATE_KEY","wallet","Wallet","abi","JSON","parse","SCOREBOARD_ADDRESS","scoreboard","Contract","_nextNonce","async","postScore","gameId","player","score","isAddress","Number","isInteger","id","nonce","getTransactionCount","address","curr","getNextNonce","tx","submitScore","wait","hash","lerp","b","t","Game","constructor","this","height","HEIGHT","mode","p1","x","y","PADDLE_HEIGHT","p2","WIDTH","ball","dx","dy","inputs","applyInput","dir","update","PADDLE_SPEED","Math","max","min","med1","BALL_ACCEL","med2","resetBall","random","getState","type","dbPath","DB_PATH","recursive","db","err","console","error","log","serialize","run","runAsync","sql","values","Promise","resolve","reject","lastID","getAsync","params","rejects","row","prodDir","devDir","publicDir","exit","waiting","sessions","Map","socketToSession","app","register","secret","COOKIE_SECRET","parseOptions","JWT_SECRET","cookie","cookieName","signed","sign","expiresIn","name","scope","credentials","client","GOOGLE_CLIENT_ID","GOOGLE_CLIENT_SECRET","auth","startRedirectPath","callbackUri","GOOGLE_CALLBACK_URL","callbackUriParams","access_type","pkce","decorate","request","reply","cookies","headers","authorization","jwtVerify","send","post","userName","email","password","body","status","hashPass","now","Date","toString","userWallet","createRandom","privKey","privateKey","idUser","code","user","token","jwt","sub","setCookie","httpOnly","sameSite","preHandler","authenticate","res","maxAge","ok","uri","googleOAuth2","generateAuthorizationUri","redirect","accessToken","getAccessTokenFromAuthorizationCodeFlow","access_token","response","fetch","userInfo","json","salt","hashedSub","hashedEmail","all","jwtToken","message","details","fastify","websocket","socket","payload","localLoop","localAI","localGame","on","raw","msg","stringify","vs","length","opponent","shift","sessionGame","loopTimer","setInterval","state","session","game","sockets","players","set","youAre","push","parseFloat","difficulty","paddleSpeed","noise","lastObservation","targetY","snapshot","paddleX","bx0","by0","bx","by","vx","vy","paddleCenter","delta","abs","startAI","sess","who","ply","clearInterval","score1","score2","delete","row1","row2","tx1","tx2","undefined","item","findIndex","w","splice","idx","req","txHash","scores","getScores","map","r","fetchScores","root","prefix","index","wildcard","_req","ico","header","setNotFoundHandler","url","startsWith","callNotFound","sendFile","PORT","listen","port","host","then","catch"],"sourceRoot":""}